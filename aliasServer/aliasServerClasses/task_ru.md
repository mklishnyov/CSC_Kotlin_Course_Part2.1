### Псевдонимы типов

[Псевдоним типа](https://kotlinlang.org/docs/type-aliases.html) позволяет вам определить альтернативное имя для существующего типа. Наиболее распространенное применение псевдонимов типов — сокращение длинных имен типов. В этом случае вы можете использовать другое более короткое имя:

```kotlin
typealias Words = List<String>

// Далее вы можете использовать <Words> в любом случае, когда вам нужен <List<String>>:
fun foo(): Words = TODO() // должен вернуть List<String>
```

### Классы

#### Общее определение

В процессе разработки программного обеспечения часто непрактично реализовывать всё приложение, используя только функции как строительные блоки. Если вы проектируете крупную сложную систему и используете принципы объектно-ориентированного программирования, вы можете разделить приложение на несколько сущностей, каждая из которых ответственна за свою функциональность.

Рассмотрим настольную игру в качестве примера. Допустим, у нас есть сущность `GameCard` и функция для генерации списка слов внутри неё. Конечно, мы можем реализовать функцию, которая будет возвращать определенный список слов отдельно, без связи с сущностью `GameCard`. Однако сущность `GameCard` может иметь некоторые _свойства_, например, ее вместимость. В этом случае вам нужно будет вручную передавать все свойства сущности `GameCard` в функцию и впоследствии отслеживать их. Это неудобно и подвержено ошибкам.

#### Определение в Kotlin

**Классы** могут выступать такими специальными сущностями, подобно `GameCard`. В Kotlin для определения нового класса необходимо использовать ключевое слово [`class`](https://kotlinlang.org/docs/classes.html):

```kotlin
class GameCard
```

#### Свойства

Далее вы можете задать все _свойства_ в [_первичном конструкторе_](https://kotlinlang.org/docs/classes.html#constructors), который должен хранить каждый _экземпляр_ этого класса:

```kotlin
class GameCard(val capacity: Int = 5)
```
В приведённом выше примере мы указали, что каждая карта в игре имеет вместимость, и стандартная вместимость равна пяти.

```kotlin
class GameCard(val capacity: Int = 5)

// Далее мы можем создать новый экземпляр
fun main() {
    val card1 = GameCard() // новая карта с вместимостью 5

    val card2 = GameCard(4) // новая карта с вместимостью 4
}
```

Проще говоря, вы создаёте новый тип, который затем можете использовать в вашей программе:

```kotlin
class GameCard(val capacity: Int = 5)

fun foo(card: GameCard): Unit = TODO("Не реализовано")
```

<div class="hint" title="Нажмите, чтобы увидеть пример с несколькими свойствами в классе">

В классах можно добавлять несколько свойств:
  ```kotlin
  class GameCard(
    val capacity: Int = 5,
    val contentType: String,
  )
  
  // Далее мы можем создать новый экземпляр
  fun main() {
    val card1 = GameCard(contentType = "word") // новая карта с вместимостью 5 и contentType "word"
  
    val card2 = GameCard(4, "word") // новая карта с вместимостью 4 и contentType "word"
  }
  ```
</div>

#### Методы

Кроме того, каждый класс может иметь набор _методов_. Проще говоря, это функции, которые могут быть вызваны на любом _экземпляре_ этого класса. Внутри таких функций доступны как аргументы метода, так и все _свойства_ класса:

```kotlin
class GameCard(val capacity: Int = 5) {
    fun generateNewWords(language: String = "en") : List<String> {
        // Здесь можно использовать <language> и <capacity>
        TODO("Not implemented yet")
    }
}
```

Далее вы можете вызвать метод, указав имя метода после имени сущности с точкой:

```kotlin
fun main() {
    val card = GameCard() // новая карта с вместимостью 5
    val words = card.generateNewWords()
}
```

#### Модификаторы доступа

Классы могут иметь свойства и методы, но некоторые из них могут быть внутренними. Чтобы ограничить их использование, мы можем применить специальные _модификаторы доступа_. По умолчанию все свойства и методы имеют модификатор `public`, что означает, что они могут быть использованы отовсюду. Однако если вы укажете модификатор `private`, то они могут быть использованы только внутри класса. Существуют и другие модификаторы, которые мы рассмотрим позже.

<div class="hint" title="Нажмите, чтобы увидеть пример модификаторов доступа">

По умолчанию все модификаторы `public`:

```kotlin
class GameCard(val capacity: Int = 5) {
    fun generateNewWords(language: String = "en") : List<String> {
        TODO("Not implemented yet")
    }
  
    fun anotherFunction() {
        val a = capacity // OK
        val b = generateNewWords() // OK
    }
}

fun main() {
    val card = GameCard() // новая карта с вместимостью 5
    card.capacity // OK
    card.generateNewWords() // OK
}
```

Однако мы можем изменить их на `private`:

```kotlin
class GameCard(private val capacity: Int = 5) {
    private fun generateNewWords(language: String = "en") : List<String> {
        TODO("Not implemented yet")
    }

    fun anotherFunction() {
        val a = capacity // OK
        val b = generateNewWords() // OK
    }
}

fun main() {
    val card = GameCard() // новая карта с вместимостью 5
    card.capacity // ОШИБКА
    card.generateNewWords() // ОШИБКА
}
```

</div>

Если вы разрабатываете большое или сложное приложение, помните о необходимости использовать различные модификаторы доступа, включая `private`.

<div class="hint" title="Нажмите, чтобы увидеть примеры использования различных модификаторов доступа">

Модификатор `private` часто используется для внутренней функциональности внутри класса, например, если вы создаёте вспомогательную функцию, чтобы избежать дублирования кода в изначальной функции:

  ```kotlin
  class GameCard(val capacity: Int = 5) {
    fun generateNewWords(language: String = "en") : List<String> {
      val words: List<String> = TODO("Не реализовано")
      return words.filter { isValidWord(it) }
    }
  
    private fun isValidWord(str: String): Boolean  = str.all { it.isLetter() }
  }
  ```

В приведённом выше примере мы создали приватную функцию `isValidWord` для отсеивания только валидных слов для карты. Однако это внутреняя функция, специфичная для этого класса, отражающая внутренюю логику генерации слов. В таком случае мы должны отметить её как `private`.
</div>