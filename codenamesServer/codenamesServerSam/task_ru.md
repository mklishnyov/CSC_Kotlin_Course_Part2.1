#### Общее определение

[Функциональные (SAM, Single Abstract Method) интерфейсы](https://kotlinlang.org/docs/fun-interfaces.html) применимы в ситуации, когда есть тип сущности с единственным методом. Рассмотрим пример настольной игры. Наша игра имеет KeyCard, которая хранит игровое поле для двух лидеров. Но как должна быть сгенерирована KeyCard? Должны ли KeyCard быть уникальными или они могут повторяться? Можем ли мы иметь несколько режимов игры с разными стратегиями генерации KeyCard? Все эти вопросы приводят к следующему выводу - любая стратегия нуждается в собственном генераторе, который может генерировать KeyCard в соответствии с определенными правилами. Генератор стратегии — хороший кандидат на объявление как SAM интерфейс.

#### Определение в Kotlin

В Kotlin интерфейсы SAM определяются с использованием ключевых слов `fun interface` и должны содержать ровно одну функцию. Эта функция _должна_ быть без реализации, и она будет реализована позже в новом классе, который будет _реализовывать_ этот SAM интерфейс:

```kotlin
fun interface StringGenerator {
    fun generate(alphabet: List<Char>): String
}
```

Далее, мы можем реализовать различные генераторы, например, генератор, который использует только буквы:

```kotlin
class OnlyLettersGenerator: StringGenerator {
    override fun generate(alphabet: List<Char>): String {
        return alphabet
            .filter { it.isLetter() }
            .shuffled()
            .take(3)
            .joinToString("")
    }
}
```

Поскольку начальному SAM интерфейсу не реализована функция `generate`, мы не можем создать экземпляр этого интерфейса, но мы можем создать новый экземпляр нового класса, который _реализует_ SAM интерфейс `StringGenerator`:

```kotlin
fun main() {
    val baseGenerator = StringGenerator() // ОШИБКА
    
    val onlyLettersGenerator = OnlyLettersGenerator() // ОК
    println(onlyLettersGenerator.generate(listOf('a', 'b', 'c', 'd', '5'))) // некоторая строка, состоящая из 3 различных английских букв
}
```

#### Определение функции

Если вам нужно определить класс, реализующий SAM интерфейс, _только один раз_
и в будущем не нужно обращаться к этому классу по его имени, вы можете, например,
сохранить новый экземпляр класса в переменную или свойство - тогда вы можете использовать только имя SAM интерфейса
и реализовать функцию в фигурных скобках:

```kotlin
object Settings {
    val onlyLettersGenerator = StringGenerator {
            alphabet -> alphabet
                .filter { it.isLetter() }
                .shuffled()
                .take(3)
                .joinToString("")
    }
}
```

Затем вы можете использовать его так же, как в предыдущем примере:
```kotlin
fun main() {
    println(Settings.onlyLettersGenerator.generate(listOf('a', 'b', 'c', 'd', '5'))) // некоторая строка, состоящая из 3 различных английских букв
}
```